#ifndef SPEC
#define SPEC

#include <string>
#include <memory>
#include <list>
#include <chrono>

class HImage; //из библиотеки
class FSDK_FaceTemplate; //тоже

//Для начала, стоит иметь возможность отслеживать статус происходящей работы. 
//Иметь некий объект, передавать его по ссылке, и в случае возникновения ошибки сообщать этому оьъекту статус.
//После того, как отработала та или иная функция проверять состояние объекта
class OperationStatus {
public:
    OperationStatus() : hasError(false) {};

    void setError(const std::string& newError) {
        error = newError;
        hasError = !error.empty();
    }
    bool hasError() const {
        return hasError;
    }
    std::string getError() const {
        return error;
    }

private:
    std::string error;
    bool hasError;    
};

//Что мы имеем - некая видеозапись, которую необходимо обработать. 
//Видеозапись может быть предоставлена в абсолютно любом формате. 
//Поскольку разобрать кажый формат отдельно достаточно сложно и не является целью работы, мы считаем, что видеозапись подается на вход некоему стороннему инструменту,
//а на выход мы получаем раскадровку данной видеозаписи.
//Итак, еще раз: на вход идет некая видеозапись -> на выход мы получаем набор кадров этой видеозаписи
//Вход предполагается сделать в виде ссылки на видеозапись,
//Вывод - лист объектов HImage, существующих в библиотеке LuxandFaceSDK
//Что необходимо обдумать:
//1) "Внутреннюю магию" обработки видео. Скорее всего, стоит использовать какую-то стороннюю библиотеку.
//2) Кадров может быть очень много. Возможно, уже на этом этапе стоит включать либо не все (1-2 в секунду)
//либо сразу проверять, есть ли на них лица и если да, то включать такие кадры
//
//Мне видится, что лучше всего будет сразу связать изображение с видеозаписюь, которой это изображение принадлежит

//Это - маркер времени. Все, что связано с временем - время появления того или иного кадра, длительность и т.д. и .тп
//предлагается поместить именно сюда
//Библиотека chrono должна содержать много полезного и интересного для этого
//TODO: подробно с ней разобраться и продумать этот класс
class Time; 

class Image {
public:
    Image(HImage* _image, const int id) : image(_image), videoId(id) {};
    //Перегрузить деструктор и прочее

private:
    HImage* image;
    int     videoId;//Хранить видео можно по ID. Как его определить - решить позже
    Time    time; //определять момент данного кадра. Нужно чуть по-лучше разобраться с библиотекой chrono чтобы понять, что лучше использовать
};
std::list<Image*> processVideoInput(OperationStatus& os, const std::string& inputVideoUrl);

//Теперь мы имеем список фотографий, которые нам необходимо обработать
//На всякий случай стои иметь функцию, которая говорит, есть ли вообще на фотографии лица
//А еще лучше - сразу посчитать, сколько их (их же может быть больше одного)
int countFacesInPhoto(OperationStatus& os, HImage* image) const;

//У нас есть фотография и мы знаем, что на ней есть лица.
//Теперь нам нужно найти те самые "описания" данных лиц
//Еще раз - лицо может быть не одно, поэтому возращаемым значением логичнее сделать сразу лист
//FSDK_FaceTemplate - библиотечная структурка, которая как раз содержит "лицевые оссобенности"
//
//Аналогично как и с изображением - свяжем реультат и сзображением, которому он принадлежит
class FaceDescription{
public:
    FaceDescription(FSDK_FaceTemplate* faceTemplate, Image* _image)
        : image(_faceTemplate), image(_image) {};
    //Перегрузить деструктор и прочее

private:
    FSDK_FaceTemplate* faceTemplate;
    Image*             image;
};
std::list<FaceDescription*> getFacesFromPhoto(OperationStatus& os, HImage* image) const;

//Нам необходимо "сохранить в базе данных все «описания лиц» в связке с идентификатором видеоматериала и найденными временными интервалами;"
//Поскольку у нас "описание лица" связано с изображением, на котором оно находится, а изображение - с видеозаписью, которой оно принадлежит,
//то получается, что для каждого "описания лица" мы можем одноначно пределить, с какого оно видео и из какого момента.
//Таким образом, есдинственным аргументом функции записи в базу мы можем сделать экземпляр класса FaceDescription
void write2Database(OperationStatus& os, FaceDescription* faceDescription);

//Поиск по базе данных так же - нам нужно передать в функцию искомое описание лиц, а на выход получить набор лиц, вероятность совпадения с которыми выше некоего заданного порога
//который мы зададим самостоятельно
//Не лишним будет вернуть и процент сходства
std::list<std::pair<FaceDescription*, float>> findMatchingFaces(OperationStatus& os, FaceDescription* face2Detect, const float similarity);





#endif // !SPEC
