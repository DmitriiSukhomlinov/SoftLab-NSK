Для распознавания лиц написана статическая библиотека, встраиваемая в исполняемое приложение. Общий алгоритм работы библиотеки следующий - на вход подается видеозапись, которая разбивается на последовательность кадров. Каждый кадр представляется в виде изображения и на данном изображении, с помощью встраиваемой библиотеки FaceSDK, выполняется поиск лиц людей. Лица сравниваются друг с другом и формируется база данных, содержащая: лицо конкретного человека; порядковые номера кадров, на которых данное лицо встречается в данной видеозаписи; номер кадра, на котором данное лицо представлено в наилучшем виде (по версии билиотеки FaceSDK); описание лица в формате библиотеки FaseSDK с этого кадра, а так же геометрическое расположение лица на кадре.
Основная реализация библиотеки разбита на два класса. Один из них занимается непосредственно считыванием видеозаписи и разбиением ее на кадры, второй - обработкой получившегося кадра, поиском лиц на нем и составлением базы данных. Каждый класс разбит на две части - на интерфейс (абстрактный класс, в терминах языка C++) и реализацию в наследнике (наследниках). Подобная концепция необходима из соображений поставки библиотеки конечному пользователю - мы поставляем библиотеку и пару .h файлов и, в итоге, конечный пользователь имеет полный доступ к функционалу библиотеки при том, что реалиация от него скрыта.
Интерфейс класса, предназначаемого для загрузки видеозаписи представлен в файле "ILoader.h". Конструктор по-умолчанию класса скрыт в области protected, что не позволяет напрямую создавать экземпляры данного класса. Для создания объекта существует статическая функция "createLoader()", объявленная в области public. Данная функция возращает указатель на объект "ILoader", под которым скрывается экземпляр класса-наследника. Помимо этого, абстрактный класс содержит объявленными и имеющими реализацию "по-умолчанию" конструкторы копирования и перемещения, операторы присваивания копированием и перемещением и деструктор (соглано "Правилу пяти" языка C++). Так же, класс содержит набор следующих чисто виртуальных функций: "void init()" (для инициализации загрузчика), "void loadFile(const std::string& path)" (принимает единственный аргумент - путь к видеозаписи), "unsigned char* readNextFrame()" (считывание следующего кадра и возврат указателя на соответствующий данному кадру набор байт) и "finish()" (завершение работы загрузчика). Для доступа к определенным данным используется ряд функций-геттер: "int getSkanLine() const" (возвращает ширину картинки в байтах), "int getPictureWidth() const" (возвращает ширину картинки в пикселях), "int getPictureHeight() const" (возвращает высоту картинки в пикселях), "int getLastReadFrameNumber() const" (возращает порядковый номер последнего прочитанного кадра) и "bool hasFrameToRead() const" (возвращает есть ли еще кадры или нет).
Абстрактный класс реализован в наследнике "AviLoader". Данный класс предназначен для обработки видеороликов формата ".avi". Для создания обработчика видеозаписей другого формата необходимо создать другой класс, например "MkvLoader" и перегрузить в нем все необходмые чисто виртуальные функции. В данной работе мы ограничимся релизацией загрузчика ".avi" файлов. Кадры в ".avi" файле представляют из себя изображения формата ".bmp".
Данный класс использует COM (Component Object Model) библиотеку в процессе работы. Данная библиотека подключается отдельно через командную строку и дает доступ к ряду функций, необходимый для считывания ".avi" файла. Для доступа к функциям модели используется специальный указатель "CComPtr", которому в качестве аргумента шаблона передается интерфейс "IGetAVIInfo", предназначенный для читания ".avi" файлов. Данный указатель хранится как поле класса в следующем виде: "CComPtr <struct GETAVIINFOLib::IGetAVIInfo> avi;".
Класс содержит поле "int totalFrames;", в котрое записывается количество кадров видеоролика.
Класс содержит два объекта типа BITMAPINFO - "BITMAPINFO* bmpInfoIn;" и "BITMAPINFO bmpInfoOut;". В первом случае, это "сырая" информация, тебующая обработки, а именно - декомпрессии. Во втором случае, это информация об уже декомпрессованом файле. BITMAPINFO содержит в себе структуру BITMAPINFOHEADER, которая хранит информацию о кадрах - размер, ширину, высоту и .т.д, а так же он может хранить в себе сам массив данных, однако, для выполнения нашей задачи нам это не понадобится. Нам лишь необходимо правильно заполнить структуру BITMAPINFOHEADER, чтобы объекты "bmpInfoIn" и "bmpInfoOut" могли быть использованы при декомпрессии картинки. 
Класс содержит поле "int decodedImageSize;", в которое записывается размер уже декодированой картинки в байтах.
Класс содержит поле "unsigned char* decodedImage;", являющееся указателем на декодированное изображение в динамической памяти.
Класс содержит поле "int scanLine;", представляющее из себя размер памяти, приходящийся на одну строку картинки в байтах.
Класс содержит поле "HIC hic;" (HIC - Handle to a Installable Compressor), которое является декомпрессором изображения.
Класс содержит поле "HANDLE myAvi;", представляющее из себя обработчик входящего ".avi" файла.
Класс содержит поле "int frameNum;", которое является порядковым номером текущего обрабатываемого кадра.
Принцип работы класса описывается ниже:
Сначала создается экземпляр класса путем вызова единственного конструктора без аргументов. Конструктор вызывается не напрямую, а через вышеупомянутую статическую функцию "createLoader()" базового класса "ILoader".  В конструкторе происходит присвоение нулевого указателя nullptr всем полям класса, которые являются указателями, все численные поля типа int инициализируются нулем, за исключением "frameNum" - оно инициализируется "-1". Это нужно потому, что при начале работы сначала срабатывает инкремент номера кадра +1, а затем начинается обработка кадра по соответствующему порядковому номеру. Поостветственно, при первой же обработке кадра -1 превратится в 0.
После создания объекта загрузчика его необходимо инициализировать. Для этого вызывается функция "init()". Внутри функции происходит инициализация библиотеки Component Object Model(COM) путец вызова специальной функции "CoInitialize". 
После создания объекта необходимо указать, какую видеозапись обрабатывать. Для этого используется функция "loadFile", в качестве аргумента принимающая путь к видеозаписи на жестком диске. Внутри данной функции первым делом получить объект COM. Это делается с помощью функции CoCreateInstance с указанием того, какую конкретно COM библиотеку необходимо получить в качестве аргумента:
avi.CoCreateInstance(GETAVIINFOLib::CLSID_GetAVIInfo);
После вызова этой функции, "avi" будет проинициализирован. Так же, даннй вызов имеет возвращаемое значение, которые в случае успеха должно быть "S_OK".	
Имея готовую COM библиотеку мы можем начинать работу с файлом. С помощью функции "avi->Load", принимающей в качестве аргумента путь к файлу, мы можем считать ".avi" файл. Вовращаемое начение функции так же должно равняться "S_OK" в случае успеха. 
Дальше мы начинаем считывать внутренности самого ".avi" файла, отдельно сохраняя то, что нам понадобится в будущем.
Первое, что находится в ".avi" файле - это общая информация о нем, находящаяся в структуре "MainAVIHeader". Поскольку большая часть этой структуры нам не понадобится при работе, нам не имеет смысла хранить ее в качестве поля класса, поэтому мы заводим ее в качестве переменной на стеке "MainAVIHeader aviHeader;". Далее, нам необходимо получить данные "MainAVIHeader". Для этого мы вызываем функцию "avi->GetMainHeader" с тремя аргументами - указателем на начало объекта "aviHeader" на стеке ((unsigned char*)&aviHeader), размером считываемых данных (sizeof(aviHeader)) и ссылкой (&tmp) на предварительно созданную переменную (long tmp = 0;), в которую будет записан фактический размер скопированных данных. Возвращаемое значение функции так же должно равняться "S_OK". Имея "MainAVIHeader" мы можем записать единственную необходимую нам переменную "aviHeader.dwTotalFrames" - количество кадров в видеозаписи (totalFrames = aviHeader.dwTotalFrames;).












